<# //************************************************************************************************* #>
<# //----------------------------------------------------------------------- #>
<# // <copyright file="SqmCommandTargetGenerator.ttinclude" company="SonarSource SA and Microsoft Corporation"> #>
<# //   Copyright (c) SonarSource SA and Microsoft Corporation.  All rights reserved. #>
<# //   Licensed under the MIT License. See License.txt in the project root for license information. #>
<# // </copyright> #>
<# //----------------------------------------------------------------------- #>
<# //************************************************************************************************* #>
<# string enumName = FeatureName + "SqmCommandIds"; #>
// <auto-generated>
// This code was generated using text template tool.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
//
// This file contains a class that handles the SQM pseudo-commands.

using Microsoft.VisualStudio;
using Microsoft.VisualStudio.OLE.Interop;
using System;
using System.ComponentModel;
using OLEConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace <#= NamespaceName #>
{

    internal enum <#= enumName #>
    {
    <#
foreach(var sqmCmd in commands)
{
        string commandName = sqmCmd.Item1;
        string commandId = sqmCmd.Item2;
    #>
    <#= commandName #>CommandId = <#= commandId #>,
    <#
    }
    #>
}

    /// <summary>
    /// Implementation for the IOleCommandTarget
    /// to log SQM data for the <#= FeatureName #> feature.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal class <#= FeatureName #>SqmCommandTarget : IOleCommandTarget
    {
        #region Fields
        internal static readonly Guid CommandSetIdentifier = new Guid("{<#= CommandSetIdentifier #>}");
        #endregion

        #region IOleCommandTarget
        public int Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            if (IsSqmCommand(pguidCmdGroup, (int)nCmdID))
            {
                 return VSConstants.S_OK;
            }
            return (int)OLEConstants.OLECMDERR_E_NOTSUPPORTED;
        }

        public int QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            // This handler enables ALL pseudo commands for logging SQM data.
            // i.e. all commands in guid group <#= FeatureName #>SqmCommandTarget.CommandSetIdentifier
            // are pseudo commands for logging SQM and this handler will enable them when fired.

            int commandId = (int)prgCmds[0].cmdID;
            if (IsSqmCommand(pguidCmdGroup, commandId))
            {
                prgCmds[0].cmdf =
                    (uint)OLECMDF.OLECMDF_SUPPORTED |
                    (uint)OLECMDF.OLECMDF_ENABLED;
                return VSConstants.S_OK;
            }
            return (int)OLEConstants.OLECMDERR_E_NOTSUPPORTED;
        }

        #endregion

        /// </summary>
        /// Returns true if the specified command is a recognized SQM command, otherwise false.
        /// </summary>
        public static bool IsSqmCommand(Guid commandGroup, int commandId)
        {
            if (commandGroup == <#= FeatureName #>SqmCommandTarget.CommandSetIdentifier)
            {
                <#= enumName #> sqmCommandId = (<#= enumName #>)commandId;
                switch (sqmCommandId)
                {
<#
                foreach(var sqmCmd in commands)
                {
                    string commandName = sqmCmd.Item1;
#>
                    case <#= enumName #>.<#= commandName #>CommandId:
<#
                }
#>
                    {
                        return true;
                    }
                }
            }
            return false;

        }

    }

}
